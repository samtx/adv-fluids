# Autogenerated with SMOP 
from smop.core import *
import numpy as np
import scipy.linalg
import matplotlib

# Force matplotlib to not use any Xwindows backend.
matplotlib.use('Agg')

    
@function
def calc_orrsommerfeld(alpha=None,R=None,N=None,*args,**kwargs):
    varargin = calc_orrsommerfeld.varargin
    nargin = calc_orrsommerfeld.nargin

    # Matlab script to find global eigenvalues for Poiseuille flow
    
    # The collocation points are at ybar=cos(m*pi/(N-1)) for m=0..N-1
# Setup matrix t of Chebyshev polynomials and their derivatives at each collocation
# point
    
    for m in arange(N - 2,2,- 1).reshape(-1):
        ybar=np.cos(dot(m,np.pi) / (N - 1))
# calc_orrsommerfeld.m:10
        t=0.0
# calc_orrsommerfeld.m:11
        t[1,1]=1.0
# calc_orrsommerfeld.m:12
        t[1,2]=ybar
# calc_orrsommerfeld.m:13
        for ii in arange(2,N - 1).reshape(-1):
            t[1,ii + 1]=dot(dot(2.0,ybar),t[1,ii]) - t[1,ii - 1]
# calc_orrsommerfeld.m:15
        for j in arange(2,5).reshape(-1):
            t[j,1]=0.0
# calc_orrsommerfeld.m:18
            t[j,2]=t[j - 1,1]
# calc_orrsommerfeld.m:19
            t[j,3]=dot(4.0,t[j - 1,2])
# calc_orrsommerfeld.m:20
            for k in arange(4,N).reshape(-1):
                t[j,k]=dot(dot(2.0,(k - 1.0)),t[j - 1,k - 1]) + dot((k - 1.0) / (k - 3.0),t[j,k - 2])
# calc_orrsommerfeld.m:22
        # Evaluate the base flow at value of ybar
        U=1.0 - ybar ** 2.0
# calc_orrsommerfeld.m:26
        dU=dot(- 2.0,ybar)
# calc_orrsommerfeld.m:27
        d2U=- 2.0
# calc_orrsommerfeld.m:28
        for j in arange(1,N).reshape(-1):
            a[N - m,j]=dot(U,(t[3,j] - dot(alpha ** 2,t[1,j]))) - dot(d2U,t[1,j]) - dot(1.0 / (dot(dot(1j,alpha),R)),(t[5,j] - dot(dot(2.0,alpha ** 2),t[3,j]) + dot(alpha ** 4.0,t[1,j])))
# calc_orrsommerfeld.m:31
            b[N - m,j]=t[3,j] - dot(alpha ** 2,t[1,j])
# calc_orrsommerfeld.m:32
    
    # Boundary conditions
    for j in arange(1,N).reshape(-1):
        a[1,j]=1.0
# calc_orrsommerfeld.m:38
        a[2,j]=(j - 1.0) ** 2.0
# calc_orrsommerfeld.m:39
        a[N - 1,j]=dot((- 1.0) ** (j - 2.0),(j - 1.0) ** 2.0)
# calc_orrsommerfeld.m:40
        a[N,j]=(- 1.0) ** (j - 1.0)
# calc_orrsommerfeld.m:41
        b[1,j]=0.0
# calc_orrsommerfeld.m:42
        b[2,j]=0.0
# calc_orrsommerfeld.m:43
        b[N - 1,j]=0.0
# calc_orrsommerfeld.m:44
        b[N,j]=0.0
# calc_orrsommerfeld.m:45
    
   # Find eigenvalues c
    V,D = scipy.linalg.eig(a,b)
    print('D=',D)
    diagD = np.diag(D)
    print('diagD.shape=',diagD.shape)
    print('diagD=',diagD)
    imagc = diagD.imag
    realc = diagD.real
    # fig, ax = plt.subplots()
    plt.plot(realc, imagc, 'o')
    plt.axis([0, 1, -1, 0.1])
    plt.xlabel('c_r')
    plt.ylabel('c_i')
    plt.savefig('orrsom.png', format='png')
    
    # Check if there are positive, finite c_i
    isStable=logical(max(imagc[logical_not(isinf(imagc))]) < 0)
# calc_orrsommerfeld.m:61
    return isStable
    
if __name__ == '__main__':
    alpha = 1.0
    R = 10000
    N = 121
    calc_orrsommerfeld(alpha, R, N)
    